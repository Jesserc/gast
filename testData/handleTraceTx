package transaction

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/ethereum/go-ethereum/rpc"
)

type Trace struct {
	Type     string   `json:"type"`
	Depth    int      `json:"depth"`
	From     string   `json:"from"`
	To       string   `json:"to"`
	Value    string   `json:"value,omitempty"`
	Input    string   `json:"input"`
	Parent   *Trace   `json:"-"` // Exclude from JSON marshaling
	Children []*Trace `json:"-"`
}

const (
	colorReset  = "\033[0m"
	colorRed    = "\033[31m"
	colorGreen  = "\033[32m"
	colorYellow = "\033[33m"
	colorBlue   = "\033[34m"
	colorPurple = "\033[35m"
	colorCyan   = "\033[36m"
	colorWhite  = "\033[37m"
)

func handleTraceTx(hash, rpcUrl string) (string, error) {
	var (
		client *rpc.Client
		err    error
	)

	if rpcUrl == "" {
		client, err = rpc.Dial("https://rpc.builder0x69.io/")
		if err != nil {
			return "", err
		}
	} else {
		client, err = rpc.Dial(rpcUrl)
		if err != nil {
			return "", err
		}
	}

	// params := map[string]interface{}{
	// 	"tracer": "callTracer",
	// 	"tracerConfig": map[string]interface{}{
	// 		"onlyTopCall": false,
	// 		"withLog":     true,
	// 	},
	// }

	var result json.RawMessage
	// err = client.CallContext(context.Background(), &result, "trace_transaction", hash, params)
	err = client.CallContext(context.Background(), &result, "ots_traceTransaction", hash)
	if err != nil {
		return "", err
	}

	var traces []Trace
	if err := json.Unmarshal(result, &traces); err != nil {
		return "", err
	}

	// Organize traces into a hierarchical structure
	rootTrace := buildTraceHierarchy(traces)

	// Pretty print the trace
	// printTrace(rootTrace, 0)
	printTrace(rootTrace, 0, false, "")
	return "output", nil
}

func buildTraceHierarchy(traces []Trace) *Trace {
	var root *Trace
	lastAtDepth := make(map[int]*Trace)

	for i, trace := range traces {
		current := &traces[i] // Get a reference to the trace in the slice

		if trace.Depth == 0 {
			root = current // This is the root trace
		} else {
			parent := lastAtDepth[trace.Depth-1] // Parent is the last trace at the previous depth
			current.Parent = parent
			parent.Children = append(parent.Children, current)
		}

		lastAtDepth[trace.Depth] = current // Update the last trace at this depth
	}

	return root // Return the root of the trace hierarchy
}

//	func printTrace(trace *Trace, indentLevel int) {
//		indent := strings.Repeat(" ", indentLevel*4)
//		fmt.Printf("%sType: %s, From: %s, To: %s, Depth: %d, Input: [%v]\n\n", indent, trace.Type, trace.From, trace.To, trace.Depth, formatInput(trace.Input))
//
//		for _, child := range trace.Children {
//			printTrace(child, indentLevel+1) // Recursively print children
//		}
//	}

func printTrace(trace *Trace, indentLevel int, isLastChild bool, prefix string) {
	var indent, currentPrefix string
	if indentLevel > 0 {
		indent = strings.Repeat("    ", indentLevel-1) // Basic indentation for hierarchy level
		if isLastChild {
			currentPrefix = prefix + "└── " + colorGreen + "← " + colorReset
			prefix += "    " // Extend the prefix for child traces without a connecting line
		} else {
			currentPrefix = prefix + "├── " + colorGreen + "← " + colorReset
			prefix += "│   " // Add a vertical line for child traces
		}
	}
	formattedInput := formatInput(trace.Input) // Format the input field
	fmt.Printf("%s%s%sType:%s %s, %sFrom:%s %s, %sTo:%s %s, %sDepth:%s %d, %sInput:%s [%s]\n",
		indent, currentPrefix,
		colorGreen, colorReset,
		trace.Type, colorGreen,
		colorReset, trace.From,
		colorGreen, colorReset,
		trace.To, colorGreen,
		colorReset, trace.Depth,
		colorGreen, colorReset,
		formattedInput,
	)

	for i, child := range trace.Children {
		printTrace(child, indentLevel+1, i == len(trace.Children)-1, prefix) // Recursively print children
	}
}
func formatInput(input string) string {
	if len(input) <= 4 {
		// If the input is 4 characters or fewer, just return it as is.
		return input
	}

	return input[:8] + "..." + input[len(input)-4:]
}

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
/*
func prettyPrintTraces(traces []TraceDetails, indentLevel int) {
	if traces == nil {
		return
	}
	var output string
	for i, trace := range traces {
		output += fmt.Sprintf("%sTrace %d:\n", strings.Repeat("\t", indentLevel), i+1)
		output += fmt.Sprintf("%s\tCall Type: %s\n", strings.Repeat("\t", indentLevel), trace.Action.CallType)
		output += fmt.Sprintf("%s\tFrom: %s\n", strings.Repeat("\t", indentLevel), trace.Action.From)
		output += fmt.Sprintf("%s\tTo: %s\n", strings.Repeat("\t", indentLevel), trace.Action.To)
		output += fmt.Sprintf("%s\tGas: %s\n", strings.Repeat("\t", indentLevel), trace.Action.Gas)
		output += fmt.Sprintf("%s\tValue: %s\n", strings.Repeat("\t", indentLevel), trace.Action.Value)
		output += fmt.Sprintf("%s\tInput: %s\n", strings.Repeat("\t", indentLevel), trace.Action.Input)
		output += fmt.Sprintf("%s\tOutput: %s\n", strings.Repeat("\t", indentLevel), trace.Result.Output)
		output += fmt.Sprintf("%s\tGas Used: %s\n", strings.Repeat("\t", indentLevel), trace.Result.GasUsed)

	}
	fmt.Println(output)
}
*/

/*
func run(rpcURL, transactionHash string)

	// JSON-RPC request payload
	requestData := fmt.Sprintf(`{"jsonrpc":"2.0","method":"trace_transaction","params":["%s", {}],"id":1}`, transactionHash)

	// Send HTTP POST request to the RPC endpoint
	response, err := http.Post(rpcURL, "application/json", strings.NewReader(requestData))
	if err != nil {
		fmt.Println("Error sending RPC request:", err)
		return
	}
	defer response.Body.Close()

	// Parse the JSON response
	var result map[string]interface{}
	if err := json.NewDecoder(response.Body).Decode(&result); err != nil {
		fmt.Println("Error decoding JSON response:", err)
		return
	}

	// Check for RPC errors
	if errMsg, ok := result["error"].(map[string]interface{}); ok {
		code := errMsg["code"].(float64)
		message := errMsg["message"].(string)
		fmt.Println("RPC error:", code, message)
		return
	}

	// Extract the trace result from the response
	traceResult := result["result"].(map[string]interface{})

	// Print the trace result or handle it as needed
	fmt.Println("Trace result:", traceResult)
}*/


package transaction

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/ethereum/go-ethereum/rpc"
)

func handleTraceTx(hash, rpcUrl string) (any, error) {
	client, err := rpc.Dial(rpcUrl)
	if err != nil {
		fmt.Println("line 15:", err)
		return "", err
	}

	// params := map[string]any{
	// 	"tracer": "callTracer",
	// 	"tracerConfig": map[string]any{
	// 		"onlyTopCall": true,
	// 	},
	// 	// "tracer":           "prestateTracer",
	// 	// "onlyTopCall":      true,
	// 	// "disableStack":     true,
	// 	// "disableStorage":   true,
	// 	// "disableMemory":    true,
	// 	// "enableReturnData": false,
	// }
	params := map[string]any{
		"tracer": "prestateTracer",
		// 	"onlyTopCall":      true,
		// 	"disableStack":     true,
		// 	"disableStorage":   true,
		// 	"disableMemory":    true,
		// 	"enableReturnData": false,
		// 	"diffMode":         false,
		// 	"tracer":           "callTracer",
		//
		// 	// "enableMemory":     "true",
		// 	// "disableStack":     "false",
		// 	// "disableStorage":   "false",
		// 	// "enableReturnData": "true",
	}

	var result json.RawMessage
	err = client.CallContext(context.Background(), &result, "debug_traceTransaction", params)
	if err != nil {
		return nil, err
	}

	resBytes, err := json.MarshalIndent(result, "", "/t")
	if err != nil {
		return nil, err
	}

	return string(resBytes), nil
}

// func handleTraceTx(hash, rpcUrl string) (any, error) {
// 	client, err := rpc.Dial(rpcUrl)
// 	if err != nil {
// 		fmt.Println("line 15:", err)
// 		return "", err
// 	}
//
// 	t := "callTracer"
// 	lc := logger.Config{
// 		EnableMemory:     false,
// 		DisableStack:     true,
// 		DisableStorage:   true,
// 		EnableReturnData: false,
// 		Debug:            false,
// 		Limit:            0,
// 		Overrides:        nil,
// 	}
// 	tc := tracers.TraceConfig{
// 		Config:       &lc,
// 		Tracer:       &t,
// 		Timeout:      nil,
// 		Reexec:       nil,
// 		TracerConfig: nil,
// 	}
//
// 	message, err := TraceTransaction(context.Background(), client, common.HexToHash(hash), &tc)
// 	if err != nil {
// 		return nil, err
// 	}
// 	d, err := json.MarshalIndent(message, " ", "\t")
// 	if err != nil {
// 		return nil, err
// 	}
// 	return string(d), err
// }
//
// func TraceTransaction(ctx context.Context, ec *rpc.Client, txhash common.Hash, config *tracers.TraceConfig) (json.RawMessage, error) {
// 	var result json.RawMessage
// 	err := ec.CallContext(ctx, &result, "debug_traceTransaction", txhash, config)
// 	if err != nil {
// 		return nil, err
// 	}
// 	return result, nil
// }

/*
package transaction

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
)

func handleTraceTx(hash, rpcUrl string) (any, error) {
	// client, err := rpc.Dial(rpcUrl)
	// if err != nil {
	// 	fmt.Println("line 15:", err)
	// 	return "", err
	// }
	//
	// params := map[string]any{
	// 	// "tracer":           "prestateTracer",
	// 	"onlyTopCall":      true,
	// 	"disableStack":     true,
	// 	"disableStorage":   true,
	// 	"disableMemory":    true,
	// 	"enableReturnData": false,
	// 	"diffMode":         false,
	// 	"tracer":           "callTracer",
	//
	// 	// "enableMemory":     "true",
	// 	// "disableStack":     "false",
	// 	// "disableStorage":   "false",
	// 	// "enableReturnData": "true",
	// }

	// t := tracers.TraceConfig{
	// 	Config:       nil,
	// 	Tracer:       nil,
	// 	Timeout:      nil,
	// 	Reexec:       nil,
	// 	TracerConfig: nil,
	// }

	url := rpcUrl

	// Prepare the request body
	requestBody, err := json.Marshal(map[string]interface{}{
		"id":      1,
		"jsonrpc": "2.0",
		"method":  "debug_traceTransaction",
		"params": []interface{}{
			hash,
			map[string]any{
				/*	"tracer": "callTracer",
					"tracerConfig": map[string]any{
						"withLog": true,
// 					},*/
// "tracer": "prestateTracer",
// "tracerConfig": map[string]any{
// "diffMode": true,
// },
// },
// // map[string]string{
// // 	"tracer": "4byteTracer",
// // },
// },
// })
// if err != nil {
// fmt.Println("Error creating request body:", err)
// return nil, err
// }
//
// // Create the HTTP POST request
// req, err := http.NewRequest("POST", url, bytes.NewBuffer(requestBody))
// if err != nil {
// fmt.Println("Error creating HTTP request:", err)
// return nil, err
//
// }
//
// // Set headers
// req.Header.Set("Accept", "application/json")
// req.Header.Set("Content-Type", "application/json")
//
// // Send the request
// client := http.Client{}
// resp, err := client.Do(req)
// if err != nil {
// fmt.Println("Error sending request:", err)
// return nil, err
//
// }
// defer resp.Body.Close()
//
// // Read the response body
// var response map[string]interface{}
// err = json.NewDecoder(resp.Body).Decode(&response)
// if err != nil {
// fmt.Println("Error decoding response body:", err)
// return nil, err
//
// }
// marshalIndent, err := json.MarshalIndent(response, " ", " ")
// if err != nil {
// return nil, err
// }
// // Print the response
// fmt.Println("Response:", string(marshalIndent))
// return "", nil
// }

// func handleTraceTx(hash, rpcUrl string) (any, error) {
// 	client, err := rpc.Dial(rpcUrl)
// 	if err != nil {
// 		fmt.Println("line 15:", err)
// 		return "", err
// 	}
//
// 	t := "callTracer"
// 	lc := logger.Config{
// 		EnableMemory:     false,
// 		DisableStack:     true,
// 		DisableStorage:   true,
// 		EnableReturnData: false,
// 		Debug:            false,
// 		Limit:            0,
// 		Overrides:        nil,
// 	}
// 	tc := tracers.TraceConfig{
// 		Config:       &lc,
// 		Tracer:       &t,
// 		Timeout:      nil,
// 		Reexec:       nil,
// 		TracerConfig: nil,
// 	}
//
// 	message, err := TraceTransaction(context.Background(), client, common.HexToHash(hash), &tc)
// 	if err != nil {
// 		return nil, err
// 	}
// 	d, err := json.MarshalIndent(message, " ", "\t")
// 	if err != nil {
// 		return nil, err
// 	}
// 	return string(d), err
// }
//
// func TraceTransaction(ctx context.Context, ec *rpc.Client, txhash common.Hash, config *tracers.TraceConfig) (json.RawMessage, error) {
// 	var result json.RawMessage
// 	err := ec.CallContext(ctx, &result, "debug_traceTransaction", txhash, config)
// 	if err != nil {
// 		return nil, err
// 	}
// 	return result, nil
// }


