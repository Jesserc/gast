package transaction

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/ethereum/go-ethereum/rpc"
)

func handleTraceTx(hash, rpcUrl string) (any, error) {
	client, err := rpc.Dial(rpcUrl)
	if err != nil {
		fmt.Println("line 15:", err)
		return "", err
	}

	// params := map[string]any{
	// 	"tracer": "callTracer",
	// 	"tracerConfig": map[string]any{
	// 		"onlyTopCall": true,
	// 	},
	// 	// "tracer":           "prestateTracer",
	// 	// "onlyTopCall":      true,
	// 	// "disableStack":     true,
	// 	// "disableStorage":   true,
	// 	// "disableMemory":    true,
	// 	// "enableReturnData": false,
	// }
	params := map[string]any{
		"tracer": "prestateTracer",
		// 	"onlyTopCall":      true,
		// 	"disableStack":     true,
		// 	"disableStorage":   true,
		// 	"disableMemory":    true,
		// 	"enableReturnData": false,
		// 	"diffMode":         false,
		// 	"tracer":           "callTracer",
		//
		// 	// "enableMemory":     "true",
		// 	// "disableStack":     "false",
		// 	// "disableStorage":   "false",
		// 	// "enableReturnData": "true",
	}

	var result json.RawMessage
	err = client.CallContext(context.Background(), &result, "debug_traceTransaction", params)
	if err != nil {
		return nil, err
	}

	resBytes, err := json.MarshalIndent(result, "", "/t")
	if err != nil {
		return nil, err
	}

	return string(resBytes), nil
}

// func handleTraceTx(hash, rpcUrl string) (any, error) {
// 	client, err := rpc.Dial(rpcUrl)
// 	if err != nil {
// 		fmt.Println("line 15:", err)
// 		return "", err
// 	}
//
// 	t := "callTracer"
// 	lc := logger.Config{
// 		EnableMemory:     false,
// 		DisableStack:     true,
// 		DisableStorage:   true,
// 		EnableReturnData: false,
// 		Debug:            false,
// 		Limit:            0,
// 		Overrides:        nil,
// 	}
// 	tc := tracers.TraceConfig{
// 		Config:       &lc,
// 		Tracer:       &t,
// 		Timeout:      nil,
// 		Reexec:       nil,
// 		TracerConfig: nil,
// 	}
//
// 	message, err := TraceTransaction(context.Background(), client, common.HexToHash(hash), &tc)
// 	if err != nil {
// 		return nil, err
// 	}
// 	d, err := json.MarshalIndent(message, " ", "\t")
// 	if err != nil {
// 		return nil, err
// 	}
// 	return string(d), err
// }
//
// func TraceTransaction(ctx context.Context, ec *rpc.Client, txhash common.Hash, config *tracers.TraceConfig) (json.RawMessage, error) {
// 	var result json.RawMessage
// 	err := ec.CallContext(ctx, &result, "debug_traceTransaction", txhash, config)
// 	if err != nil {
// 		return nil, err
// 	}
// 	return result, nil
// }

/*
package transaction

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
)

func handleTraceTx(hash, rpcUrl string) (any, error) {
	// client, err := rpc.Dial(rpcUrl)
	// if err != nil {
	// 	fmt.Println("line 15:", err)
	// 	return "", err
	// }
	//
	// params := map[string]any{
	// 	// "tracer":           "prestateTracer",
	// 	"onlyTopCall":      true,
	// 	"disableStack":     true,
	// 	"disableStorage":   true,
	// 	"disableMemory":    true,
	// 	"enableReturnData": false,
	// 	"diffMode":         false,
	// 	"tracer":           "callTracer",
	//
	// 	// "enableMemory":     "true",
	// 	// "disableStack":     "false",
	// 	// "disableStorage":   "false",
	// 	// "enableReturnData": "true",
	// }

	// t := tracers.TraceConfig{
	// 	Config:       nil,
	// 	Tracer:       nil,
	// 	Timeout:      nil,
	// 	Reexec:       nil,
	// 	TracerConfig: nil,
	// }

	url := rpcUrl

	// Prepare the request body
	requestBody, err := json.Marshal(map[string]interface{}{
		"id":      1,
		"jsonrpc": "2.0",
		"method":  "debug_traceTransaction",
		"params": []interface{}{
			hash,
			map[string]any{
				/*	"tracer": "callTracer",
					"tracerConfig": map[string]any{
						"withLog": true,
// 					},*/
// "tracer": "prestateTracer",
// "tracerConfig": map[string]any{
// "diffMode": true,
// },
// },
// // map[string]string{
// // 	"tracer": "4byteTracer",
// // },
// },
// })
// if err != nil {
// fmt.Println("Error creating request body:", err)
// return nil, err
// }
//
// // Create the HTTP POST request
// req, err := http.NewRequest("POST", url, bytes.NewBuffer(requestBody))
// if err != nil {
// fmt.Println("Error creating HTTP request:", err)
// return nil, err
//
// }
//
// // Set headers
// req.Header.Set("Accept", "application/json")
// req.Header.Set("Content-Type", "application/json")
//
// // Send the request
// client := http.Client{}
// resp, err := client.Do(req)
// if err != nil {
// fmt.Println("Error sending request:", err)
// return nil, err
//
// }
// defer resp.Body.Close()
//
// // Read the response body
// var response map[string]interface{}
// err = json.NewDecoder(resp.Body).Decode(&response)
// if err != nil {
// fmt.Println("Error decoding response body:", err)
// return nil, err
//
// }
// marshalIndent, err := json.MarshalIndent(response, " ", " ")
// if err != nil {
// return nil, err
// }
// // Print the response
// fmt.Println("Response:", string(marshalIndent))
// return "", nil
// }

// func handleTraceTx(hash, rpcUrl string) (any, error) {
// 	client, err := rpc.Dial(rpcUrl)
// 	if err != nil {
// 		fmt.Println("line 15:", err)
// 		return "", err
// 	}
//
// 	t := "callTracer"
// 	lc := logger.Config{
// 		EnableMemory:     false,
// 		DisableStack:     true,
// 		DisableStorage:   true,
// 		EnableReturnData: false,
// 		Debug:            false,
// 		Limit:            0,
// 		Overrides:        nil,
// 	}
// 	tc := tracers.TraceConfig{
// 		Config:       &lc,
// 		Tracer:       &t,
// 		Timeout:      nil,
// 		Reexec:       nil,
// 		TracerConfig: nil,
// 	}
//
// 	message, err := TraceTransaction(context.Background(), client, common.HexToHash(hash), &tc)
// 	if err != nil {
// 		return nil, err
// 	}
// 	d, err := json.MarshalIndent(message, " ", "\t")
// 	if err != nil {
// 		return nil, err
// 	}
// 	return string(d), err
// }
//
// func TraceTransaction(ctx context.Context, ec *rpc.Client, txhash common.Hash, config *tracers.TraceConfig) (json.RawMessage, error) {
// 	var result json.RawMessage
// 	err := ec.CallContext(ctx, &result, "debug_traceTransaction", txhash, config)
// 	if err != nil {
// 		return nil, err
// 	}
// 	return result, nil
// }
